<!DOCTYPE html>
<html>
<head>
    <title>About Us</title>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/static/assets/style.css"></head>
<body>
<div class="content">
    <h1>Recommended Architecture for Flutter Stores</h1>

This document outlines three recommended architectures for using the <code>flutter&lt;em&gt;stores</code> package. Each architecture
balances simplicity, scalability, and flexibility while showcasing the strengths of <code>flutter&lt;/em&gt;stores</code>. These approaches
cater to different project sizes and needs.

<hr>

<h2><strong>1. Minimal Architecture (Best for Small Projects)</strong></h2>

<ul>
<li><strong>Focus</strong>: Keep it simple with direct use of stores, and limit abstraction layers.</li>
<li><strong>When to Use</strong>: Small projects or prototypes where simplicity and speed are key.</li>
</ul>

<h3><strong>Folder Structure</strong></h3>

<pre><code>lib/
├── main.dart
├── screens/
│   ├── home<em>screen.dart
│   ├── add</em>task<em>screen.dart
│   ├── add</em>category<em>screen.dart
│   ├── search</em>screen.dart
├── store/
│   └── todo<em>store.dart
└── todo</em>provider.dart</code></pre>

<h3><strong>Key Points</strong></h3>

<ul>
<li><strong>Store Logic</strong>:<pre><code>- All state management logic is placed in the store (e.g., <code>TodoStore</code>).</code></pre></li>
<li><strong>Business Logic</strong>:<pre><code>- Basic logic stays in the store; no service or repository layer.</code></pre></li>
<li><strong>View Access</strong>:<pre><code>- Access the store directly via <code>TodoProvider.of(context)</code>.</code></pre></li>
</ul>

<h3><strong>Advantages</strong></h3>

<ul>
<li>Simple and fast to implement.</li>
<li>Easy to debug due to direct access to state.</li>
</ul>

<h3><strong>Disadvantages</strong></h3>

<ul>
<li>Not ideal for large projects (limited separation of concerns).</li>
</ul>

<hr>

<h2><strong>2. Modularized Architecture (Best for Medium Projects)</strong></h2>

<ul>
<li><strong>Focus</strong>: Separate business logic into services for better organization and maintainability.</li>
<li><strong>When to Use</strong>: Medium-sized projects with a moderate feature set.</li>
</ul>

<h3><strong>Folder Structure</strong></h3>

<pre><code>lib/
├── main.dart
├── screens/
│   ├── home<em>screen.dart
│   ├── add</em>task<em>screen.dart
│   ├── add</em>category<em>screen.dart
│   ├── search</em>screen.dart
├── store/
│   └── todo<em>store.dart
├── services/
│   └── todo</em>service.dart
├── models/
│   └── task<em>model.dart
└── todo</em>provider.dart</code></pre>

<h3><strong>Key Points</strong></h3>

<ul>
<li><strong>Store Logic</strong>:<pre><code>- Store focuses on managing state and persistence.</code></pre></li>
<li><strong>Business Logic</strong>:<pre><code>- Moved to services (e.g., <code>TodoService</code>) for reusable and testable business rules.</code></pre></li>
<li><strong>Models</strong>:<pre><code>- Use <code>TaskModel</code> or similar to ensure type safety and consistency.</code></pre></li>
<li><strong>View Access</strong>:<pre><code>- Access the store via <code>TodoProvider.of(context)</code>.</code></pre></li>
</ul>

<h3><strong>Advantages</strong></h3>

<ul>
<li>Clear separation of concerns.</li>
<li>Reusable services simplify logic and testing.</li>
<li>Type safety using models.</li>
</ul>

<h3><strong>Disadvantages</strong></h3>

<ul>
<li>Slightly more complexity compared to the minimal approach.</li>
</ul>

<hr>

<h2><strong>3. Feature-First Architecture (Best for Large Projects)</strong></h2>

<ul>
<li><strong>Focus</strong>: Organize code by features, allowing each feature to encapsulate its logic.</li>
<li><strong>When to Use</strong>: Large projects requiring scalability and feature isolation.</li>
</ul>

<h3><strong>Folder Structure</strong></h3>

<pre><code>lib/
├── main.dart
├── features/
│   ├── todo/
│   │   ├── screens/
│   │   │   ├── home<em>screen.dart
│   │   │   ├── add</em>task<em>screen.dart
│   │   │   ├── add</em>category<em>screen.dart
│   │   │   ├── search</em>screen.dart
│   │   ├── store/
│   │   │   └── todo<em>store.dart
│   │   ├── services/
│   │   │   └── todo</em>service.dart
│   │   ├── models/
│   │   │   └── task<em>model.dart
│   │   └── todo</em>provider.dart
└── common/<pre><code>├── widgets/</code></pre><pre><code>├── utils/</code></pre><pre><code>└── themes/&lt;/code&gt;&lt;/pre&gt;</code></pre>

<h3><strong>Key Points</strong></h3>

<ul>
<li><strong>Feature Isolation</strong>:<pre><code>- Each feature has its own screens, stores, services, and models.</code></pre></li>
<li><strong>Shared Logic</strong>:<pre><code>- Place reusable widgets, utilities, and themes in <code>common/</code>.</code></pre></li>
<li><strong>Scalability</strong>:<pre><code>- Add new features by creating a new folder under <code>features/</code>.</code></pre></li>
</ul>

<h3><strong>Advantages</strong></h3>

<ul>
<li>Highly scalable and organized.</li>
<li>Easy to onboard developers due to clear structure.</li>
<li>Promotes encapsulation and modularity.</li>
</ul>

<h3><strong>Disadvantages</strong></h3>

<ul>
<li>Slightly more upfront setup.</li>
<li>Requires discipline to maintain feature boundaries.</li>
</ul>

<hr>

<h2><strong>Choosing the Best Architecture</strong></h2>

1. <strong>Minimal Architecture</strong>:<pre><code>- Great for small projects, simple apps, or quick prototypes.</code></pre>
2. <strong>Modularized Architecture</strong>:<pre><code>- Best for medium-sized apps requiring reusable business logic.</code></pre>
3. <strong>Feature-First Architecture</strong>:<pre><code>- Ideal for large, scalable apps with multiple independent features.</code></pre>

<hr>

These architectures leverage the flexibility and simplicity of <code>flutter_stores</code>, ensuring maintainability and
scalability without unnecessary boilerplate. Choose the architecture that best fits the size and scope of your project.</div>
<footer class="site-footer">
    <p>&copy; 2025 Generated by Forge Static Module. All rights reserved.</p>
</footer></body>
</html>